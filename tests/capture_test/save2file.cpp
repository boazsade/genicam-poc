#include "save2file.h"
#include <opencv2/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/calib3d/calib3d.hpp>
#include <filesystem>
#include <fstream>

inline auto colorize(cv::InputArray input, cv::OutputArray rgb) -> void {
    cv::cvtColor(input, rgb, cv::COLOR_BayerRG2RGB);
}

auto show_image(const std::uint8_t* data, int width, int height, int number, const char* name) -> void {
    using namespace std::string_literals;
    constexpr auto row_step = 30;       
    auto row = row_step;

    cv::Mat rgb(height, width, CV_8UC1, (void*)data);
    colorize(rgb, rgb);
    cv::resize(rgb, rgb, cv::Size(), 0.5, 0.5);
    std::string buf("FrameData:  #: "s + std::to_string(number));
    putText(rgb, buf.c_str(), cv::Point(row_step, row), cv::HersheyFonts::FONT_HERSHEY_SIMPLEX, 0.7, cv::Scalar(0, 0, 255), 2);
    row += row_step;
    auto title{"Image "s + name};
    cv::imshow(title, rgb);
    cv::waitKey(1);
}

auto show_images(const ImageBase frames) -> void {
    if (frames.data) {
        show_image(frames.data, frames.width, frames.height, frames.number, "left");
    } else {
        std::cerr << "We don't have a valid frame for front left for frame number " << frames.number << "\n";
    }
    // if (frames._RFrontal) {
    //     show_image(frames._RFrontal, 4'096, 3'000, frames->GetBlockID(), "right");
    // } else {
    //     std::cerr <<  "missing right frame for image number " <<  frames->GetBlockID() << "\n";
    // }
}

auto dump_image(std::ofstream& out_file, ImageBase frame) -> void {
    // Hard coded TIFF header (and pointer)
	static const unsigned char HEADER[] = {0x49, 0x49, 0x2A, 0x00, 0x08, 0x80, 0xBB, 0x00};
	// Hard coded TIFF tags and IFD
	// Without ColorMatrix1 (from LibTIFF program)
	static const unsigned char FOOTER[] = {
		0x15, 0x00, 0xFE, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x01, 0x00,
		0x00, 0x00, 0xB8, 0x0B, 0x00, 0x00, 0x02, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00,
		0x00, 0x00, 0x03, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x06, 0x01,
		0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x23, 0x80, 0x00, 0x00, 0x0F, 0x01, 0x02, 0x00, 0x09, 0x00,
		0x00, 0x00, 0x0A, 0x81, 0xBB, 0x00, 0x10, 0x01, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00, 0x14, 0x81,
		0xBB, 0x00, 0x11, 0x01, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x12, 0x01,
		0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x15, 0x01, 0x03, 0x00, 0x01, 0x00,
		0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x17, 0x01, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x80,
		0xBB, 0x00, 0x1C, 0x01, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x31, 0x01,
		0x02, 0x00, 0x12, 0x00, 0x00, 0x00, 0x24, 0x81, 0xBB, 0x00, 0x8D, 0x82, 0x03, 0x00, 0x02, 0x00,
		0x00, 0x00, 0x02, 0x00, 0x02, 0x00, 0x8E, 0x82, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x01, 0x02, 0x12, 0xC6, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x13, 0xC6,
		0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0xC6, 0x02, 0x00, 0x07, 0x00,
		0x00, 0x00, 0x36, 0x81, 0xBB, 0x00, 0x1D, 0xC6, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0xFF, 0x00,
		0x00, 0x00, 0x5A, 0xC6, 0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x47, 0x72, 0x6F, 0x57, 0x69, 0x6E, 0x67, 0x73, 0x00, 0x00, 0x47, 0x72, 0x6F, 0x57,
		0x69, 0x6E, 0x67, 0x73, 0x20, 0x63, 0x61, 0x6D, 0x65, 0x72, 0x61, 0x00, 0x67, 0x72, 0x6F, 0x77,
		0x69, 0x6E, 0x67, 0x73, 0x2D, 0x72, 0x65, 0x63, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x00, 0x47, 0x52,
		0x57, 0x2D, 0x78, 0x31, 0x00 
	};

    if (out_file.write((const char*)HEADER, sizeof(HEADER)) &&
        out_file.write((const char*)frame.data, frame.size) &&
	    out_file.write((const char*)FOOTER, sizeof(FOOTER))) {
        std::cout << "successfully saved image of size " << frame.size << "[" << frame.width << " x " << frame.height << std::endl;
        //LOG(INFO) << "successfully saved image to [" << to << "]" << ENDL;
    } else {
        std::cerr << "failed to save image\n";
    }
}

auto do_save(ImageBase image) -> void {
    static auto make_path = []() {
        std::filesystem::path base_path = std::filesystem::temp_directory_path() / "vimba_images" / std::string{"images_dir_" + std::to_string(time(nullptr))};
        std::filesystem::create_directories(base_path);
        return base_path;
    }();

    if (image.data) {
        auto base = make_path / std::string{"image_number_" + std::to_string(image.number) + ".dng"};
        std::ofstream output(base);
        dump_image(output, image);
    }
}